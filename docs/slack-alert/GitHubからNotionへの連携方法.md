
## 実現可能性の結論

GitHub ActionsからNotion APIを用いた自動処理は実現可能である。ただし、内部統合トークンの使用が禁止されている制約条件下においては、公開インテグレーションとOAuth 2.0認証を組み合わせた方式が最適解となる。この方式により、セキュリティポリシーに準拠しつつ、特定データベースへの読み取り・書き込みを完全自動化できる。

## 推奨される実装方法

内部統合トークンに代わり、Notionの公開インテグレーション機能とOAuth 2.0プロトコルを活用する。具体的には、事前にNotion開発者ページで公開インテグレーションを作成し、OAuthクライアントID及びシークレットを発行する。その後、OAuth認可フローを実行してアクセストークンを取得し、これをGitHub Secretsに保管する。取得したトークンは、内部統合トークンと同様にBearerトークンとしてAPIリクエストに使用できるが、ユーザーの明示的な許可を経て発行されている点で本質的に異なる。

この方式には複数の利点がある。第一に、アクセス権限が認可時にユーザーが選択したページやデータベースのみに限定されるため、仮にトークンが漏洩した場合でも影響範囲を最小化できる。第二に、OAuth経由で発行されたトークンはリフレッシュトークンによる更新に対応しており、将来的にNotionが有効期限ポリシーを導入した際にも柔軟に対応可能である。第三に、組織のセキュリティポリシーにおいて「OAuthなど限定的な認可方式」が許容されている場合、この手法は完全に準拠した実装となる。

一方で、考慮すべき制約も存在する。OAuth認可の初回実行時には、ブラウザでNotionの認可画面にアクセスし、手動で許可を与える必要がある。また、発行されたアクセストークン自体は依然として機密情報であり、適切な管理体制が不可欠である。

## 実装手順の概要

実装は大きく三段階に分けられる。まずNotion側で公開インテグレーションを作成し、OAuth認可フローを実行してアクセストークンを取得する。次に、取得したトークンとデータベースIDをGitHub Secretsに登録する。最後に、GitHub ActionsのワークフローYAMLファイルとAPI操作用のスクリプト（Node.jsやPythonなど）を実装する。

スクリプト内では、公式のNotion SDKクライアント（例: `@notionhq/client`）を使用し、環境変数から読み込んだトークンで認証を行う。データベースからのページ読み取りには`databases.query`メソッドを、新規ページ作成には`pages.create`メソッドを使用する。これらの操作は、内部統合トークンを使用する場合と技術的に同一であり、トークンの発行方式が異なるのみである。

ワークフローは、スケジュール実行や手動トリガーなど、任意のイベントで起動できる。実行環境としてはGitHub提供のホストランナー（ubuntu-latestなど）を使用し、外部サービスを経由せずNotionと直接通信する構成となる。

## OAuthクライアントシークレット漏洩時のリスク

実装方法として推奨されるOAuth方式においても、OAuthクライアントID及びシークレットが漏洩した場合のリスクを正しく理解しておく必要がある。

### 直接的な影響と攻撃シナリオ

OAuthクライアントシークレットが漏洩すると、攻撃者は認可コード（authorization code）を不正に使用してアクセストークンを取得できる可能性がある。ただし、この攻撃が成立するには認可コード自体も同時に入手する必要があり、認可コードは通常数分で失効する短命な値であるため、クライアントシークレット単体の漏洩だけでは即座にアクセストークンを生成することはできない。

しかし、クライアントID及びシークレットが漏洩した状態が継続すると、複数の間接的なリスクが顕在化する。第一に、攻撃者が漏洩した認証情報を用いて正規のOAuth認可フローを模倣したフィッシングサイトを構築し、ユーザーを騙して認可を取得することで、攻撃者自身のサーバーにアクセストークンを送信させることが可能になる。第二に、OAuth設定でリダイレクトURLが適切に制限されていない場合、攻撃者は別のリダイレクト先を指定して認可コードを横取りできる可能性がある。第三に、組織内で既にOAuth認可フローが実行されており、その過程で認可コードがログやネットワーク通信履歴に残っている場合、攻撃者はそれを入手してクライアントシークレットと組み合わせることで不正にアクセストークンを取得できる可能性がある。

### 内部統合トークンとの比較

重要な点として、OAuthクライアントシークレットの漏洩リスクは、内部統合トークンの漏洩よりは影響が限定的である。内部統合トークンは、それ自体がNotionへの直接的なアクセス権限を持つBearerトークンであり、漏洩した瞬間から攻撃者は即座にNotionデータにアクセスできる。一方、OAuthクライアントシークレットはトークン取得のための中間的な認証情報であり、実際にNotionにアクセスするには追加で認可コードが必要となる。したがって、多層防御の観点では、内部統合トークンを直接使用するよりもOAuth方式の方が相対的に安全性が高いと言える。

### 漏洩時の対処法と予防策

万が一クライアントID及びシークレットが漏洩した場合は、直ちにNotion開発者ページで新しいシークレットを再生成し、古いシークレットを無効化する必要がある。同時に、発行済みアクセストークンに不審なアクセスパターンがないか監査を実施し、必要に応じて当該インテグレーション全体を一時停止する。また、OAuth設定においてリダイレクトURLを最小限に絞り、ワイルドカードや不要なURLを削除することで、攻撃者によるリダイレクト先の悪用を防止できる。

漏洩リスクを最小化するための推奨運用として、アクセストークンの取得は初回のみ手動で実行し、発行されたアクセストークンのみをGitHub Secretsに保存する方法が挙げられる。この運用では、GitHub Actions上でクライアントシークレットを使用する必要がなくなるため、GitHub環境からのクライアントシークレット漏洩リスクを完全に排除できる。

## セキュリティ上の考慮事項

### 基本的なトークン管理

トークン管理においては、GitHub Secretsの基本的な保護機能を活用する。Secretsに登録された値はワークフローログに自動マスクされ、リポジトリの閲覧権限とは独立して管理される。より高度なセキュリティが求められる場合は、GitHub ActionsのOIDC（OpenID Connect）機能を利用し、AWS Secrets ManagerやHashiCorp Vaultなどの外部シークレット管理基盤と連携する方法も検討に値する。この構成では、ワークフロー実行時に短命な一時認証情報を発行し、それを用いて外部ストアからNotionトークンを取得するため、GitHub上にトークンを恒久的に保存する必要がなくなる。

### Google Secret Manager + Workload Identity連携による最高水準のセキュリティ

Google Cloud Platform（GCP）を利用している組織においては、Google Secret Manager（GSM）とWorkload Identity連携を組み合わせた構成が、現時点で実現可能な最も安全な方法の一つとなる。この構成では、NotionのOAuthクライアントシークレット、アクセストークン、リフレッシュトークンなどの全ての機密情報をGSM内に保管し、GitHub ActionsからはWorkload Identity Federation経由で一時的にアクセスする形となる。

この方式には複数の顕著な利点がある。第一に、GitHub Actions上に一切の長期的な機密情報を保存する必要がなくなる。GitHub Secretsに保存するのはGCPプロジェクトIDやサービスアカウント名などの識別子のみであり、これらは機密性が極めて低い情報である。第二に、Workload Identityで発行されるトークンはデフォルトで作成から1時間後に自動的に期限切れとなるため、仮にワークフロー実行中にこのトークンが漏洩したとしても、攻撃者が利用できる時間窓が極めて限定される。第三に、GSMではシークレットごとに詳細なIAMポリシーを設定でき、Workload Identity経由でアクセスするサービスアカウントに対し、特定のシークレットIDへの最小限の権限のみを付与することで、必要最小限の権限原則を厳密に実装できる。さらに、特定のGitHubリポジトリ・ブランチ・環境からのアクセスのみを許可する条件付きIAMを設定すれば、同一組織内の別リポジトリであってもシークレットにアクセスできないよう制限可能である。

第四に、Google Cloud Auditログには「いつ・誰が・どのシークレットに・どのような操作をしたか」が詳細に記録される。GitHub ActionsからWorkload Identity経由でアクセスした場合も、サービスアカウント名、GitHubリポジトリ名、コミットSHA等のメタデータがログに残るため、セキュリティ監査やインシデント調査において極めて有用である。これは内部統合トークンをGitHub Secretsに直接保存する方法では得られない可視性である。第五に、GSMにNotionのアクセストークンとリフレッシュトークンの両方を保存しておけば、別の定期ワークフローでリフレッシュトークンを使用してアクセストークンを更新し、新しいトークンをGSMに書き戻す自動ローテーション機構を実装できる。

実装においては、事前にWorkload Identity FederationのプールとプロバイダーをGCP側で設定し、GitHubから送信されるOIDCトークンの属性（リポジトリ名、ブランチ名等）をGCP側の属性にマッピングする必要がある。その上で、特定のGitHubリポジトリからのアクセスのみを許可するよう、条件付きでサービスアカウントに適切なロールを付与する。ワークフロー内では、Google提供の認証アクションを使用してWorkload Identity認証を実行し、その後gcloudコマンドまたはGoogle Cloud SDKを通じてGSMからシークレットを取得する。この際、ワークフローには`id-token: write`権限の付与が必須となる。

この構成は、提示された全ての要件と制約条件を満たすだけでなく、それを上回るセキュリティレベルを達成する。GSMは組織の管理下にあるGCPインフラであり、Zapier等の外部SaaSとは性質が異なるため、外部サービス非使用という制約にも抵触しない。実装コストは若干増加するが、過去にトークン漏洩事故があり内部統合トークンの使用が禁止されているという組織的背景を考慮すると、この構成は技術的に優れているだけでなく、ガバナンス・コンプライアンス要件にも最大限応える設計となっている。

### 権限制限とトークン有効期限

権限制限に関しては、OAuth認可時に必要最小限のページまたはデータベースへのアクセスのみを許可する。また、ワークフロー自体にも最小権限の原則を適用し、例えばGitHubリポジトリへの書き込み権限が不要であれば`contents: read`のみを付与する。

トークンの有効期限については、Notionの現行仕様では明示的に失効させない限りアクセストークンは有効であるとされている。ただし、不正利用の兆候が検知された場合は、Notion側でインテグレーションを即座に無効化し、新しいトークンを再発行する運用を確立しておくべきである。

## 要件及び制約条件の充足状況

提示された要件は以下の通り充足される。第一に、OAuth初回認可後は人手を介さず自動的に処理が完了する。第二に、アクセス対象はトークンで許可された特定データベース内のページに限定される。第三に、API呼び出しを含む全ての処理ロジックがGitHubリポジトリ内で完結する。

制約条件についても完全に遵守可能である。内部統合トークンは使用せず、OAuth 2.0という限定的な認可方式で代替する。権限範囲は認可時にユーザーが選択した特定データベースのみに制限される。ZapierやMake.comなどの外部自動化サービスを経由せず、GitHub ActionsからNotion APIへ直接通信する。最後に、トークン等の機密情報はGitHub Secretsまたは外部シークレット管理基盤で安全に管理される。

したがって、本調査の結論として、提示された全ての要件と制約条件を満たす形でのGitHub ActionsからのNotion API自動連携は十分に実現可能であると言える。特に、Google Secret ManagerとWorkload Identity連携を採用することで、セキュリティレベルを最高水準に引き上げつつ、組織のガバナンス要件にも完全に対応した実装が可能となる。
